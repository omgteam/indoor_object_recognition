5a6
> 
6a8
> 
14,16d15
< from convolutional_mlp import LeNetConvPoolLayer
< from parameters import *
< if __name__ == '__main__':
17a17,86
> 
> class LeNetConvPoolLayer(object):
>     """Pool Layer of a convolutional network """
> 
>     def __init__(self, rng, input, filter_shape, image_shape, poolsize=(2, 2)):
>         """
>         Allocate a LeNetConvPoolLayer with shared variable internal parameters.
> 
>         :type rng: numpy.random.RandomState
>         :param rng: a random number generator used to initialize weights
> 
>         :type input: theano.tensor.dtensor4
>         :param input: symbolic image tensor, of shape image_shape
> 
>         :type filter_shape: tuple or list of length 4
>         :param filter_shape: (number of filters, num input feature maps,
>                               filter height,filter width)
> 
>         :type image_shape: tuple or list of length 4
>         :param image_shape: (batch size, num input feature maps,
>                              image height, image width)
> 
>         :type poolsize: tuple or list of length 2
>         :param poolsize: the downsampling (pooling) factor (#rows,#cols)
>         """
> 
>         assert image_shape[1] == filter_shape[1]
>         self.input = input
> 
>         # there are "num input feature maps * filter height * filter width"
>         # inputs to each hidden unit
>         fan_in = numpy.prod(filter_shape[1:])
>         # each unit in the lower layer receives a gradient from:
>         # "num output feature maps * filter height * filter width" /
>         #   pooling size
>         fan_out = (filter_shape[0] * numpy.prod(filter_shape[2:]) /
>                    numpy.prod(poolsize))
>         # initialize weights with random weights
>         W_bound = numpy.sqrt(6. / (fan_in + fan_out))
>         self.W = theano.shared(numpy.asarray(
>             rng.uniform(low=-W_bound, high=W_bound, size=filter_shape),
>             dtype=theano.config.floatX),
>                                borrow=True)
> 
>         # the bias is a 1D tensor -- one bias per output feature map
>         b_values = numpy.zeros((filter_shape[0],), dtype=theano.config.floatX)
>         self.b = theano.shared(value=b_values, borrow=True)
> 
>         # convolve input feature maps with filters
>         conv_out = conv.conv2d(input=input, filters=self.W,
>                 filter_shape=filter_shape, image_shape=image_shape)
> 
>         # downsample each feature map individually, using maxpooling
>         pooled_out = downsample.max_pool_2d(input=conv_out,
>                                             ds=poolsize, ignore_border=True)
> 
>         # add the bias term. Since the bias is a vector (1D array), we first
>         # reshape it to a tensor of shape (1,n_filters,1,1). Each bias will
>         # thus be broadcasted across mini-batches and feature map
>         # width & height
>         self.output = T.tanh(pooled_out + self.b.dimshuffle('x', 0, 'x', 'x'))
> 
>         # store parameters of this layer
>         self.params = [self.W, self.b]
> 
> if __name__ == '__main__':
>     learning_rate=0.04
>     n_epochs=10
>     batch_size=10
>     dataset='man_clean.pkl.gz'
37a107,109
>                         # [int] labels
> 
>     ishape = (80, 80)
43a116
>     nkerns=[16, 96, 2400]
69c142
<     layer4 = LogisticRegression(input=layer3.output, n_in=500, n_out=13)
---
>     layer4 = LogisticRegression(input=layer3.output, n_in=500, n_out=11)
108a182,187
>     # early-stopping parameters
>     patience = 10000  # look as this many examples regardless
>     patience_increase = 2  # wait this much longer when a new best is
>                            # found
>     improvement_threshold = 0.995  # a relative improvement of this much is
>                                    # considered significant
178c257
<     f = file(params_file, 'wb')
---
>     f = file('param_clean.save', 'wb')
